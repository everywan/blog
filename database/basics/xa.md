# XA事务

XA事务, 分布式事务, 实现思想参考PC二阶段提交算法, 主要用于分布式系统中的事务提交(一次事务涉及到多个网络节点中的服务)

流程如下
1. XA start 开始一个 XA 事务, 并设置为 active 状态
2. 执行事务内的sql
3. 对于 active 状态的XA事务, XA end 将该事务置为 IDLE 状态
4. 对于 IDLE 状态的XA事务
  - XA prepare 将事务置为 prepare 状态. XA recover 可以列出处于 prepare 状态的XA事务.
  - `XA commit xid one phase` 用于预备和提交事务. 此时 XA recover 不会列出该事务, 因为该事务已经终止.
5. 对于 prepare 状态的XA事务
  - XA commit 用于提交并终止事务
  - XA rollback 回滚并终止事务
```sql
XA start `xid`
--sql
xa end `xid`
xa prepare `xid`
xa commit `xid`
```
有如下注意点
1. xid 必须全局唯一
2. 启用xa事务时, 无法启用本地事务(transaction)

## 分布式事务的实现

分布式事务

----

假设在转账事务中, 账户A转账给账户B. 将主要操作抽象为两个服务: AddAction/MinusAction, 分别负责加钱/扣款.

MinusAction 先从账户A扣款, 成功后Publish消息到队列, MinusAction 只要保证当且仅当扣款成功后, 才推送消息到队列, 且必须保证消息推送到队列, 否则事务回滚.

AddAction 从消息队列读取消息, 然后扣款, 只要保证消费不成功时, 不丢弃消息即可.

----

如果在执行AddAction时, 发现账户B不存在怎么办? (假设账户B是在转账后注销的账户) 即分布式事务的问题.
1. 假设消息队列的持久化由消息队列本身负责.
2. 假设 AddAction/MinusAction 部署在两个服务中. 分开部署的原因参考 [SOA](#SOA)
3. 假设除了 加钱/扣款 外, 还需要创建转账记录(抽象为 RecordAction). 为了更具有通用性. 当只有两个时, 可以将异步的操作放到最后从而实现事务, 不具备通用性.
4. 假设要求同步. 当不要求 AddAction 与 MinusAction 同步时(即可以延迟通知执行结果), 可以添加服务 RollbackAction, 在AddAction失败后在发送一条消息给 RollbackAction, 执行回滚.

剩下的问题就是, 如何实现分布式事务了.

----

X/Open DTP 模型:

2PC 参考 分布式系统/一致性算法

3PC 

[Seata](https://github.com/seata/seata) 是阿里开源的一款分布式事务框架.

注意
1. 超时策略: 避免失效事务无限制占用资源.
2. 幂等

#### SOA
> 参考 [SOA和微服务架构的区别-何明璐的回答](https://www.zhihu.com/question/37808426/answer/93335393)

SOA, Service-Oriented Architecture, 面向服务的体系结构. 将业务的不同功能单元/服务通过服务之间良好的接口/契约联系起来. 接口是采用中立的方式进行定义的, 它应该独立于实现服务的硬件平台, 操作系统和编程语言. 这使得构建在各种各样的系统中的服务可以使用一种统一和通用的方式进行交互.

微服务是在 SOA 之后提出的理念, 微服务相当于 SOA + 业务系统更进一步的组件化和服务化, 即依照SOA拆分服务接口, 然后独立 开发/设计/运维 的服务. 

具体了解可以通过如下例子: 假设我们想要做一个可以将各国语言翻译成中文的程序, 我们有如下做法

----

为每个语言开发一个工具包, 调用 trans 方法即可将该语言转换为中文, 然后在主程序中引入各个语言包. 项目结构如下
````
- entry/main.go
- languages
  - english
  - japanese
  - ...

package english
- trans.go
````

这么写有如下缺点: (基础包代指 languages 下的各个语言包)
1. 耦合度高: 当基础包里的函数直接被外界调用时, 由于基础包不知道暴露的函数是否被外界使用, 所以不能更改任何已暴露的函数, 否则可能导致其他业务崩溃. 变量等同理.
2. 运维困难: 每次更改基础包时, 即使只更改一个, 也需要重新编译/部署整个项目. 且当某一功能存在问题时, 可能导致整个业务崩溃(如english包转换时出现问题, 导致无限占用资源, 就会导致整个进程逐渐卡死)
3. 扩展困难: 当单机无法满足业务量时, 如访问量增大, 只能通过增加节点解决.

---

SOA 解决了业务中耦合度的问题, 为之后服务拆分打下基础. 关于如何拆分业务, 可以了解下 业务领域模型.

引入SOA: 基础包定义服务接口, 服务保证接口实现的功能的稳定, 对外屏蔽服务的具体实现. 此时基础包接口如下
````
package english
- internal    // 在go中, 外界包访问不到internal下的内容
  - trans.go  // 定义具体实现
- trans.go    // 定义需要暴露的结构体和接口
````

---

各服务经过拆分后, 我们发现只要解决服务间通信的问题, 就可以通过单独部署各服务从而解决运维和扩展的问题.

刚开始, 企业一般使用 ESB 作为服务间通信工具. 因为我对ESB不太了解, 所以不再详述.

后来, 微服务的概念兴起, 各个服务通过 http/rpc/amqp 等方式互相通信, 服务通过docker部署等.

当然, 微服务使用的技术目前也不只这些, 以后也许会更多. 这里主要想说的是, 微服务的理念 = SOA + 进一步的组件化/服务化, 如上文中给的定义. 当然, 技术是在不断演进的, 后续关于此术语的描述可能不断变化, 但其思想是不变的, 如 最近很火的 面向接口编程, 不就是SOA思想么? 如微服务化, 也算是分布式系统的一种体现吧. 所以, 不要纠结于术语/定义, 要了解其思想. (就像设计模式一样, 需要求神不求形)
