<!-- TOC -->

- [一致性](#一致性)
    - [介绍](#介绍)
    - [Quorum系统NRW策略](#quorum系统nrw策略)
    - [两阶段提交算法](#两阶段提交算法)
    - [分布式锁服务](#分布式锁服务)
        - [Lamport面包店算法](#lamport面包店算法)
        - [Paxos算法](#paxos算法)
        - [Raft算法](#raft算法)
    - [引用](#引用)

<!-- /TOC -->

## 一致性
---
### 介绍
通过CAP理论可知, 在设计一个分布式系统时, 只能满足 一致性, 可用性, 分区容忍性 的两点. 但是因为网络分区是非人为控制的, 所以设计师要在一致性和可用性之间做出抉择.
- 建议在看一致性之前, 先了解下 [cap定律和base理论](/application/distributed_system/cap_base.md), 在讨论任何分布式系统时, CAP总是核心的需求.

本文所讲的是, 在分布式系统中, 一致性有那些级别, 分布式系统的一致性与其他编程领域的一致性有什么区别, 以及分布式系统的一致性有哪些方式实现

一致性按照种类划分有三种, 分别是
- 强一致性: 任意时刻, 所有节点的数据都是相同的.
- 弱一致性: 任意时刻, 所有节点的数据不一定都是相同的. 弱一致性有很多不同的实现, 分布式系统中常用的是最终一致性.
- 最终一致性: 最终一致性保证两点: 保证用户最终能够读取到数据最新状态的值; 保证不同节点上的相同的数据总在趋向于变得一致.

按照不同领域, 事务中所指的一致性与分布式系统所指的一致性又有所不同, 事务的一致性关注 事务执行的中间状态是否对外界可见, 分布式系统的一致性着重于多个节点的值保持相同. 但是, 数据库中 CAP 所指的一致性与分布式系统中的一致性基本相同.
- 具体参考 [事务-一致性](/application/database/basics/transaction.md#一致性)

最后, 我们讲讲分布式系统中的一致性有哪些实现. 赶时间的同学可以直接从 [分布式锁服务](#分布式锁服务) 开始, 个人感觉这一部分是重点. 比较闲的同学可以从基础的 [Quorum系统NRW策略](#quorum系统nrw策略) 开始. 

---
### Quorum系统NRW策略
NRW策略是强一致性算法, 性能较最终一致性算法的系统低.

Quorum机制, 是分布式系统中一种保证数据冗余和最终一致性的算法, 主要思想来源于 鸽巢原理
- 鸽巢原理: 若有N个笼子和N+1只鸽子, 所有的鸽子都关在笼子里, 那么至少有一个笼子里有两个鸽子. 

NRW策略, 解释如下:
- N: 数据拥有的副本数
- R: 完成读操作所需要读取的最小副本数. 即一次读操作所需要参与的最小节点数目.
- W: 完成写操作所需要写入的最小副本数. 即一次写操作所需要参与的最小节点数目.

NRW策略, 就是指: 只要保证 `R+W>N`, 就可以保证强一致性. 即在 N 个副本中, 有 R 个更新到最新的数据, 读取任意大于 N-R 的副本, 那么至少有一个副本的数据是最新的数据(使用 **版本号/时间戳等** 标记数据的版本, 用于判断是否是最新的数据)

当 R+W>N 时, 那么分布式系统是 强一致性 的系统.

当 R+W<=N 时, 分布式系统是 弱一致性 的系统, 是否能实现 最终一致性 取决于系统异步更新的实现方式.

R W 可以根据系统的特点进行合理的设置, 比如一下特例
1. W=1, R=N: 每次只需写入等待一个节点返回正常写入的回应即可, 读取时读取全部节点的数据. 适合写入操作很多, 但读取操作很少的系统. 但是若有一个节点故障, 则读操作无法完成.
2. W=N, R=1: 与 1 相反.
3. W=R=N/2+1: 均衡上面两个情况

---
### 两阶段提交算法
在两阶段提交协议中, 系统一般包含两类节点: 协调者(coordinator/master), 通常一个系统中只有一个; 事务参与者(participants/cohorts/workers), 一般有多个, 在数据系统中可以理解为数据副本的个数. 两阶段提交算法正常执行情况下分两步进行:

1. 阶段一: 请求阶段. 在请求阶段, 协调者通知事务参与者准备 提交或取消事务, 然后进入表决阶段. 在表决过程中, 参与者告诉协调者自己的决策: 同意或不同意事务(同意指事务在参与者本地执行成功, 不同意指事务在本参与者本地执行失败, 如消息未到达, 如超时)(注意, 事务在本地执行失败, 是指客观因素导致的, 而不是因为数据/服务本身的问题导致的失败)
2. 阶段二: 提交阶段. 协调者根据第一轮的投票结果进行决策, 确定 事务提交或者取消. 当且仅当所有的参与者同意提交事务, 协调者才通知所有参与者提交事务, 否则通知所有参与者取消事务. 参与者在收到协调者发送的消息后立即执行相应的操作.

示例如下: ABCD四个人准备去爬山, A作为活动的发起者, BCD作为活动的参与者. 如果所有人都同意去爬山, 那么活动准备进行, 如果有一个参与者不同意, 那么活动取消, 使用2pc算法解决流程如下
1. 阶段一: A 告诉 BCD, 下周去爬山, 然后A等待BCD的回应. BC收到信息, 回复A同意下周去爬山, D由于网络故障等原因没有及时收到信息(通信延迟), 此时 ABC 等待 D 的回应.第二天D收到A的消息, 但是D下周有事不能去爬山(事务在本地执行失败), 所以D回应A不同意
2. 阶段二: A 根据所有参与者的回应, 发现D拒绝了提议, 所以A通知BCD下周活动取消. BCD 收到消息后重新把下周的计划清空(回滚到之前的状态).

两阶段提交算法在分布式系统中主要用于: 单用户对多数据副本的修改, 或者多数据副本的同步:
1. 在分布式系统中, 客户端成为系统的协调者, 各个数据节点作为系统的参与者.
2. 阶段一: 客户端(协调者) 向所有参与者(数据节点)发送消息: 修改的数据的信息 --> 收到消息的数据节点 备份修改前的数据(以备回滚) --> 修改数据, 成功则回应客户端修改成功, 修改失败则回应客户端修改失败 --> 客户端收到数据节点成功的回应, 则回复ok, 如果是错误回应, 则回复错误, 取消修改
3. 阶段二: 客户端根据所有的回应, 如果全部成功 则提示修改成功, 如果存在失败的回应, 那么发信息给所有数据节点 回滚数据, 取消更改

可以看出, 两阶段提交算法还有其他很多的玩法, 比如说不需要BCD全部回复成功, 只要保证部分成功即可; 或者说错误重试, 或者说可以有多个提议, 参与者根据策略选择最新的/特殊的协议更新数据. 总之, 两阶段提交算法/Quorum机制 都是一种分布式系统中保持一致性的思想. 接下来我们开始接触下目前比较常用的其他一致性算法思想.

---
### 分布式锁服务
分布式锁是指 系统外部(用户)修改系统内数据时, 要先获得 操作许可(锁), 只有获得许可的用户才能修改数据, 用户修改完数据后释放锁. 一般而言, 同一时间只能有一个用户取得 操作许可(锁), 即只有前一个用户释放锁后, 其他用户才能重新获得锁.

分布式锁算法的实现中, 可以通过控制内容颗粒度上锁. 如, 如果需要保持文件的多个副本一直, 那么对整个文件上锁; 也可以对文件分段, 只对文件的部分内容上锁.

常用的 分布式锁 实现算法有 Lamport bakery algorithm(俗称面包店算法), Paxos算法 和 乐观锁.

#### Lamport面包店算法
Lamport面包店算法 由 _Leslie Lamport_ 发明, 是为了解决多个线程并发访问 单用户资源 的互斥问题, 多个线程之间共享该资源.

该算法也称为 时间戳策略, 或者 Lamport逻辑时钟.

在分布式系统中, 可以将 **事件的先后关系** 理解为逻辑时钟, 使用 `->` 表示. 如 事件A发生在事件B之前, 那么 `A->B`. 

事件的先后关系, 需满足以下条件
1. 如果AB是同一进程中的事件, A在B之前发生, 那么 `A->B`
2. 如果A是消息发送方, B是消息接收方, 那么 `A->B`
3. 对于事件ABC, 有 `A->B`, `B->C`, 那么 `A->C`
4. 对于任何事件A, `A->A` 是不成立的. 因为事件A是一个事件, 具有原子性.

根据如上定义(事件的先后关系), **并发(concurrent)** 的概念定义如下:
- 对于事件AB, 如果 `A->B, B->A` 都不成立, 那么 A和B 就是并发的.
- 并发并不是指一定同时发生, 而是表示事件先后关系的不确定性. 也可以理解为 可以并发的事件 之间没有依赖.

逻辑时钟, 本质上是指一个事件到实数(假设时间是连续的)的函数, 该函数将 一个事件映射到一个实数, 表示该事件发生的时间. 举例而言, 就是: 对于 进程Pi, 时钟为Ci, 对于 进程Pi 中的 事件a, Ci将A映射到Ci(a). 整个系统的时钟中, 对于 进程Pi 中的 事件b, C(b)==Ci(b).
- 注意, 这里的映射是单射.(待验证)
- 如果事件在进程 pi pj 中并发发生, 即 `Ci(a)==Cj(a')` 且 `i<j`, 那么 a 在 a' 前.

逻辑时钟的设置规则如下
1. 如果是 进程Pi 内的任何两个连续事件, 那么Ci值递增
2. 如果事件a是Pi发送消息m, 事件b是Pj接收消息m, 那么 `Ci(a)<Cj(b)`

面包店算法/时间戳策略/逻辑时钟 其实很简单, 类似与我们去吃饭时的排号策略, 每个顾客都去前台领取一个号码, 然后按照号码顺序(时间戳/逻辑时钟)依次进桌(获取操作 共享资源 的权限).
- 如果两个顾客有相同的号码, 则年龄较小的具有优先权; 在系统中即进程ID较小的具有优先权.
- 在逻辑时钟策略中, 我们更多的是去了解在分布式系统中 先后事件的关系, 以及分布式系统中的并发概念. 逻辑时钟与分布式系统结合, 就可以实现分布式锁

接下来开始学习 Paxos算法. 据说, 目前所有已实现系统中的算法, 不是Paxos,就是Paxos算法的变种. 其中, Raft算法是zookeper中采用的算法, 也是Paxos算法的变种.

#### Paxos算法
我们重点讲下 Paxos算法.



Paxos算法是2pc(两阶段提交算法)的升级版, 

#### Raft算法

### 引用
- [浅析数据一致性](http://www.importnew.com/20633.html)
- [Paxos算法的通俗理解](https://www.cnblogs.com/yeahwell/p/4703219.html)
- [Raft算法(Raft论文翻译)](http://blog.51cto.com/liuxp0827/1899354)
