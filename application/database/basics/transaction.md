<!-- TOC -->

- [Transaction](#transaction)
    - [分布式事务](#分布式事务)
    - [ACID](#acid)
        - [原子性](#原子性)
        - [一致性](#一致性)
        - [隔离性](#隔离性)
        - [持久性](#持久性)
        - [总结](#总结)
    - [锁](#锁)

<!-- /TOC -->

## Transaction
> 参考 [书籍: 数据库系统概念中文版](https://item.jd.com/27492259491.html), 讲的很详细

事务(Transaction)是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元(Unit), 狭义上的事务特指数据库事务.

### 分布式事务
1. 分布式锁+两阶段提交

### ACID
ACID 是指数据库在写入或更新数据的过程中, 为保证事务是正确可靠所依赖的四个特性: 原子性(atomicity), 一致性(consistency), 隔离性(isolation), 持久性(durability).

ACID特性主要解决以下问题: 
- 并发事务读写相同数据, 事务提供相应的隔离方法, 防止彼此操作互相干扰.
- 事务执行操作异常时回滚

各自定义如下

#### 原子性
一个事务中的所有操作, 要么全部完成, 要么全部不完成. 如果执行过程中发生失败, 那么数据库将数据回滚到事务开始时的状态.

#### 一致性
1. 事务必须从一个一致性状态转换到另一个一致性状态. 事务的一致性关注的是, 事务修改数据时是否对外界可见, 即修改数据是否会直接被读操作读取.
    - 一致性状态: 多个进程/事务 读取数据的一致性. 既事务 A/B 同时读写数据 a 时, A/B 读取结果的一致性.
    - 参考 [如何理解一致性-事务](http://geyifan.cn/2016/07/17/talk-about-transaction/)
2. 事务的一致性与 _分布式系统中/CAP_ 中的一致性 有所不同, 两者都是为了可以读取到数据的最新状态, 但是因为涉及到回滚等操作, 事务的一致性着重于中间状态是否可见. 而分布式系统的一致性着重于在多副本数据集中, 所有的数据都更新到最终的状态, 追求每个请求都能得到最新的数据.
    - 详细参考 [数据一致性](/basics/skill/consistency.md)
3. 按照一致性等级, 有以下级别
    - 强一致性: 事务的读操作可以立即读取到数据最新的值, 对于并发事务而言, 是指更新操作完成之后, 才可以进行读操作(锁); 对于分布式系统而言, 是指所有的节点数据都是相同的.
    - 弱一致性: 事务的读操作不一定立即读取到数据最新的值(有一定的延迟), 既不对数据的更新和读取做特别的操作, 两个事务/操作独立进行.
    - 最终一致性: 最终一致性多数用于分布式系统, 指系统中所有的数据副本, 在经过一段时间的同步后,最终达到一致性状态. 最终一致性是弱一致性的特例.
        - 最终一致性有以下变种实现: `[因果一致性,读己之所写,会话一致性,单调读一致性,单调写一致性]`

#### 隔离性
> 参考: [深入分析事务的隔离级别](http://www.hollischuang.com/archives/943)
1. 事务并发执行时互相的干扰程度. 如事务 A 在更改数据 a 的过程中, 事务 B 是否能读取到 a 正在修改的数据(事务 A 正在执行).
2. 不设置隔离时存在的问题
    - 脏读: 事务 A 修改数据 a, 但是尚未提交 --> 并发事务 B 读取到了修改后的 a 值 --> 事务 A 执行失败, 数据回滚, 事务 B 读取的值与真实值不同. 
        - 需要加锁解决
    - 不可重复读: 同一事务内两次查询的值不同: 事务A第一次查询数据得到结果 r1 --> 事务 B 修改了r1的数据 --> 事务 A 再次查询, 得到的结果r2与第一次不同
        - 需要加锁解决
    - 幻读: 同一事务内多次查询的值不同: 事务A第一次查询数据得到结果 r1 --> 事务 B 添加/删除了一条记录 --> 事务 A 再次查询, 得到的结果r2与第一次不同
        - 需要将事务串行化执行
3. 事务隔离级别如下
    - 未提交读(Read uncommitted): 即可以 read 未提交事务的值. 
        - 读取数据不加锁
        - 写数据时加 行级共享锁
    - 提交读: 只能 read 已提交事务的值, 解决脏读.
        - 事务读取数据后, 加行级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 行级排它锁, 直到事务结束才释放.
    - 可重复读: 解决不可重复读.
        - 事务开始读取数据时, 对数据加 行级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 行级排它锁, 直到事务结束才释放.
    - 串行化, 解决幻读.
        - 事务开始读取数据时, 对数据加 表级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 表级排它锁, 直到事务结束才释放.
4. 根据业务场景选择合适的隔离级别.

#### 持久性
事务提交后, 对数据库的影响是永久的.

#### 总结
在一个事务中, 原子性关注数据的状态, 即要么全部成功, 要么全部不成功, 不存在部分成功. 一致性关注执行过程中数据的可见性, 即中间状态对外不可见, 开始/结束状态对外可见. 不同的隔离级别实现了不同级别的一致性: 串行化是强一致性, 其他的都是弱一致性. 而持久性, 是指持久化保存, 理所当然的一点.

重要的事情多说一遍, 事务的一致性与 _分布式系统中/CAP_ 中的一致性 有所不同, 两者都是为了可以读取到数据的最新状态, 但是因为涉及到回滚等操作, 事务的一致性着重于中间状态是否可见. 而分布式系统的一致性着重于在多副本数据集中, 所有的数据都更新到最终的状态, 追求每个请求都能得到最新的数据.

### 锁
1. 共享锁: 如果事务 T 获取了数据项 Q 上的共享锁(记为 S ), 则事务可读 Q但不能写 Q.
2. 排它锁: 如果事务 T 获取了数据项 Q 上的排他锁(记为 X ), 则事务可读 Q又可写 Q.
3. 锁相容: 如果事务 T1 对数据项 Q 加锁 A, 如果事务 T2 可以立即对 Q 加所 B, 则认为锁 AB 相容.
    - 共享锁与共享锁相容, 但与排它锁不相容. 一个数据项 Q 上可以有多个共享锁, 但是只能有一个排它锁. 且排它锁请求必须等待所有共享锁释放

