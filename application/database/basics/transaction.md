<!-- TOC -->

- [Transaction](#transaction)
    - [分布式事务](#分布式事务)
    - [ACID](#acid)
        - [原子性](#原子性)
        - [一致性](#一致性)
        - [隔离性](#隔离性)
        - [持久性](#持久性)
        - [总结](#总结)
    - [锁](#锁)
    - [如何保证AC特性](#如何保证ac特性)

<!-- /TOC -->

## Transaction
> 参考 [书籍: 数据库系统概念中文版](https://item.jd.com/27492259491.html), 讲的很详细

事务(Transaction)是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元(Unit), 狭义上的事务特指数据库事务.

### 分布式事务
1. 分布式锁+两阶段提交

### ACID
ACID 是指数据库在写入或更新数据的过程中, 为保证事务是正确可靠所依赖的四个特性: 原子性(atomicity), 一致性(consistency), 隔离性(isolation), 持久性(durability).

ACID特性主要解决以下问题: 
- 并发事务读写相同数据, 事务提供相应的隔离方法, 防止彼此操作互相干扰.
- 事务执行操作异常时回滚

各自定义如下

#### 原子性
一个事务中的所有操作, 要么全部完成, 要么全部不完成. 如果执行过程中发生失败, 那么数据库将数据回滚到事务开始时的状态.

#### 一致性
1. 事务必须从一个一致性状态转换到另一个一致性状态. 事务的一致性关注的是, 事务修改数据时是否对外界可见, 即修改数据是否会直接被读操作读取.
    - 一致性状态: 多个进程/事务 读取数据的一致性. 既事务 A/B 同时读写数据 a 时, A/B 读取结果的一致性.
    - 参考 [如何理解一致性-事务](http://geyifan.cn/2016/07/17/talk-about-transaction/)
2. 事务的一致性与 _分布式系统中/CAP_ 中的一致性 有所不同, 两者都是为了可以读取到数据的最新状态, 但是因为涉及到回滚等操作, 事务的一致性着重于中间状态是否可见. 而分布式系统的一致性着重于在多副本数据集中, 所有的数据都更新到最终的状态, 追求每个请求都能得到最新的数据.
    - 详细参考 [数据一致性](/basics/skill/consistency.md)
3. 按照一致性等级, 有以下级别
    - 强一致性: 事务的读操作可以立即读取到数据最新的值, 对于并发事务而言, 是指更新操作完成之后, 才可以进行读操作(锁); 对于分布式系统而言, 是指所有的节点数据都是相同的.
    - 弱一致性: 事务的读操作不一定立即读取到数据最新的值(有一定的延迟), 既不对数据的更新和读取做特别的操作, 两个事务/操作独立进行.
    - 最终一致性: 最终一致性多数用于分布式系统, 指系统中所有的数据副本, 在经过一段时间的同步后,最终达到一致性状态. 最终一致性是弱一致性的特例.
        - 最终一致性有以下变种实现: `[因果一致性,读己之所写,会话一致性,单调读一致性,单调写一致性]`

#### 隔离性
> 参考: [深入分析事务的隔离级别](http://www.hollischuang.com/archives/943)
1. 事务并发执行时互相的干扰程度. 如事务 A 在更改数据 a 的过程中, 事务 B 是否能读取到 a 正在修改的数据(事务 A 正在执行).
2. 不设置隔离时存在的问题
    - 脏读: 事务 A 修改数据 a, 但是尚未提交 --> 并发事务 B 读取到了修改后的 a 值 --> 事务 A 执行失败, 数据回滚, 事务 B 读取的值与真实值不同. 
        - 需要加锁解决
    - 不可重复读: 同一事务内两次查询的值不同: 事务A第一次查询数据得到结果 r1 --> 事务 B 修改了r1的数据 --> 事务 A 再次查询, 得到的结果r2与第一次不同
        - 需要加锁解决
    - 幻读: 同一事务内多次查询的值不同: 事务A第一次查询数据得到结果 r1 --> 事务 B 添加/删除了一条记录 --> 事务 A 再次查询, 得到的结果r2与第一次不同
        - 需要将事务串行化执行
3. 事务隔离级别如下
    - 未提交读(Read uncommitted): 即可以 read 未提交事务的值. 
        - 读取数据不加锁
        - 写数据时加 行级共享锁
    - 提交读: 只能 read 已提交事务的值, 解决脏读.
        - 事务读取数据后, 加行级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 行级排它锁, 直到事务结束才释放.
    - 可重复读: 解决不可重复读.
        - 事务开始读取数据时, 对数据加 行级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 行级排它锁, 直到事务结束才释放.
    - 串行化, 解决幻读.
        - 事务开始读取数据时, 对数据加 表级共享锁, 直到事务结束才释放.
        - 事务开始更新数据时, 对数据加 表级排它锁, 直到事务结束才释放.
4. 根据业务场景选择合适的隔离级别.

#### 持久性
事务提交后, 对数据库的影响是永久的.

#### 总结
在一个事务中, 原子性关注数据的状态, 即要么全部成功, 要么全部不成功, 不存在部分成功. 一致性关注执行过程中数据的可见性, 即中间状态对外不可见, 开始/结束状态对外可见. 不同的隔离级别实现了不同级别的一致性: 串行化是强一致性, 其他的都是弱一致性. 而持久性, 是指持久化保存, 理所当然的一点.

重要的事情多说一遍, 事务的一致性与 _分布式系统中/CAP_ 中的一致性 有所不同, 两者都是为了可以读取到数据的最新状态, 但是因为涉及到回滚等操作, 事务的一致性着重于中间状态是否可见. 而分布式系统的一致性着重于在多副本数据集中, 所有的数据都更新到最终的状态, 追求每个请求都能得到最新的数据.

### 锁
1. 共享锁: 如果事务 T 获取了数据项 Q 上的共享锁(记为 S ), 则事务可读 Q但不能写 Q.
2. 排它锁: 如果事务 T 获取了数据项 Q 上的排他锁(记为 X ), 则事务可读 Q又可写 Q.
3. 锁相容: 如果事务 T1 对数据项 Q 加锁 A, 如果事务 T2 可以立即对 Q 加所 B, 则认为锁 AB 相容.
    - 共享锁与共享锁相容, 但与排它锁不相容. 一个数据项 Q 上可以有多个共享锁, 但是只能有一个排它锁. 且排它锁请求必须等待所有共享锁释放

### 如何保证AC特性
保证AC特性的原则性策略(SQL_SERVER):
- [参考: sqlserver锁定和行版本控制](https://docs.microsoft.com/zh-cn/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-2017)
- 锁: 每个事务对其所依赖的资源(如 页/表/行 等)请求不同类型的锁.
    - 锁用来阻止其他事务对本事务依赖资源的读写(避免其他事务读取到错误的数据)
    - 当事务不再依赖指定资源时, 释放锁
- 基于行的版本控制
    - 当启用了基于行版本控制的隔离级别时, 数据库引擎维护每一行的版本.
    - 应用程序可以指定事务使用行版本查看事务或查询开始时存在的数据, 而不是使用锁保护所有读取(降低因读取操作而使其他事务阻塞的机率)
- 预写事务日志: 确保在将关联的日志记录写入磁盘后再将数据修改写入磁盘.

保证AC特性的表层实现(mysql/InnoDB):
- [参考: autocommit/Commit/Rollback](https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html)
- 所有的用户操作都发生在事务中, 使用 autocommit 字段调整事务模式.
- 默认 autocommit==true 自动提交模式, 既每个SQL语句都是一个事务. 默认情况下, MySQL为每个 sql语句 启用的新连接启动会话
    - 如果该语句没有返回错误: 在每个SQL语句执行后执行提交操作
    - 如果语句返回错误: 执行提交或回滚行为(执行操作取决于错误处理逻辑)
- 可以使用 `START TRANSACTION / BEGIN ` 语句显示开始一个事务, 并用 `COMMIT / ROLLBACK` 结束事务
- 如果禁用 autocommit(或者说设置 `sutocommit=0`), 则会话始终打开一个事务.
    - `COMMIT / ROLLBACK` 语句结束当前事务和开始一个新的事务
    - 当没有显示提交事务的情况下结束会话, 则MySQL将回滚该事务

