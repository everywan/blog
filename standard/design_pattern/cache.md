# 缓存

## 缓存穿透
缓存穿透是指查询一个一定不存在的数据. 由于缓存不命中, 并且出于容错考虑, 如果从数据库查不到数据则不写入缓存, 这将导致这个不存在的数据每次请求都要到数据库去查询,失去了缓存的意义.

正常业务情况下出现此问题的概率不大, 大多数都是遭到恶意攻击才会出现.

比如说合法ID是 snowflake 生成的正数, 但是攻击者使用负数ID请求服务, 如果在服务层面没有判断参数, 就会出现大量缓存穿透从而出现问题.

解决方法也很简单
- 在服务/控制器层面添加断言, 判断参数不合法时直接返回, 不查询数据库.
- 更新缓存时加锁, 没取到锁的请求直接返回或休眠后缓存, 从而避免大量请求直接访问数据库.

## 缓存雪崩
缓存雪崩是指同一或特短时间内大量缓存集体失效, 导致此时间内大量请求直接访问数据库.

一般而言, 如果在 set/update 缓存时, 设置了统一的过期时间可能会导致缓存集体失效, 从而出现此情况.

解决方法也很简单
- set/update redis时, 过期时间加一个随机值

## 缓存并发竞争key
当key操作不需要顺序: 竞争锁即可

当key操作需要顺序: 竞争锁, 且给每个操作加时间戳(思想其实都是一样的, 可以参考分布式系统设计/并发系统设计)

## 局部性
时间局部性: 被引用一次的内存位置很可能在不远的将来被再次引用

空间局部性: 如果一个内存位置被引用了一次, 那么该位置附近的内容很可能在不远的将来被引用.

时间局部性一般涉及到内存的替换策略.

空间局部性一般涉及到存储器/内存的层级结构, 即以金字塔型的 高速缓存=>低速磁盘.

## 缓存系统的设计
> 参考 计算机组成原理-6.3.1

本节更多从程序底层来讲, 而不是上层

基于缓存的储存器层器有效的原因:
1. 较慢的存储设备比较快的设备更便宜
2. 程序倾向于展示局部性

设计缓存系统时, 需要考虑两个问题:
1. 替换策略: 即当缓存填充满后, 新的数据块如何覆盖旧数据块的策略. 一般采用 LRU(最近最少使用)
2. 放置策略: 当数据块被放入缓存时, 如何决定块的位置.
  - 随机放置: 再次访问时无法直接定位, 只能遍历查询, 代价很高.
  - hash策略: 类似map, 存在key冲突. 假设 k+1 层中的块 i 放置到 k 层中的 (i mod 4), 那么循环访问 k+1 层的第 0/4 块, 会一直发生 *冲突不命中* (k层中同一块被反复映射替换).
  - 对于redis等上层 k-v 缓存系统, 已经对使用者封装了内部实现.

其他需要考虑的:
1. 冷缓存: 对于空的缓存, 如何处理. (一般是在程序初始化时)
2. 是否设置失效时间

