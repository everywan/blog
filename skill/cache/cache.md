# 缓存

## 缓存穿透
缓存穿透是指查询一个一定不存在的数据. 由于缓存不命中, 并且出于容错考虑, 如果从数据库查不到数据则不写入缓存, 这将导致这个不存在的数据每次请求都要到数据库去查询,失去了缓存的意义.

正常业务情况下出现此问题的概率不大, 大多数都是遭到恶意攻击才会出现.

比如说合法ID是 snowflake 生成的正数, 但是攻击者使用负数ID请求服务, 如果在服务层面没有判断参数, 就会出现大量缓存穿透从而出现问题.

解决方法也很简单
- 在服务/控制器层面添加断言, 判断参数不合法时直接返回, 不查询数据库.
- 更新缓存时加锁, 没取到锁的请求直接返回或休眠后缓存, 从而避免大量请求直接访问数据库.

## 缓存雪崩
缓存雪崩是指同一或特短时间内大量缓存集体失效, 导致此时间内大量请求直接访问数据库.

一般而言, 如果在 set/update 缓存时, 设置了统一的过期时间可能会导致缓存集体失效, 从而出现此情况.

解决方法也很简单
- set/update redis时, 过期时间加一个随机值

## 缓存并发竞争key
当key操作不需要顺序: 竞争锁即可

当key操作需要顺序: 竞争锁, 且给每个操作加时间戳(思想其实都是一样的, 可以参考分布式系统设计/并发系统设计)

## 局部性
时间局部性: 被引用一次的内存位置很可能在不远的将来被再次引用

空间局部性: 如果一个内存位置被引用了一次, 那么该位置附近的内容很可能在不远的将来被引用.

时间局部性一般涉及到内存的替换策略.

空间局部性一般涉及到存储器/内存的层级结构, 即以金字塔型的 高速缓存=>低速磁盘.

## 缓存系统的设计
> 参考 计算机组成原理-6.3.1

本节更多从程序底层来讲, 而不是上层

基于缓存的储存器层器有效的原因:
1. 较慢的存储设备比较快的设备更便宜
2. 程序倾向于展示局部性

设计缓存系统时, 需要考虑两个问题:
1. 替换策略: 即当缓存填充满后, 新的数据块如何覆盖旧数据块的策略. 一般采用 LRU(Least Recently Used, 最近最少使用)
2. 放置策略: 当数据块被放入缓存时, 如何决定块的位置.
  - 随机放置: 再次访问时无法直接定位, 只能遍历查询, 代价很高.
  - hash策略: 类似map, 存在key冲突. 假设 k+1 层中的块 i 放置到 k 层中的 (i mod 4), 那么循环访问 k+1 层的第 0/4 块, 会一直发生 *冲突不命中* (k层中同一块被反复映射替换).
  - 对于redis等上层 k-v 缓存系统, 已经对使用者封装了内部实现.

其他需要考虑的:
1. 冷缓存: 对于空的缓存, 如何处理. (一般是在程序初始化时)
2. 是否设置失效时间

## 放置策略

## 替换策略
### LRU
LRU算法有两个目标
1. 查询/写入时复杂度要低
2. 最近最少使用的块容易被找到. (可根据访问时间+访问次数)

对于每个节点
1. 当插入/更改时, 更新 时间记录, 一般是1s. 需要提供 `server.lruclock` 服务
2. 记录使用次数字段

----

通常可以想到如下两种实现方法

插入时排序: 构建链表, 当插入新元素时, 遍历链表, 判断链表中是否已经存在该元素
1. 如果不存在: 首先判断内存是否充足, 是则将新元素插入链表的合适位置, 否则先删除队列尾元素, 然后将新元素插入合适位置.
  - 合适位置: 即使是最新使用的, 也不一定在队列头. 因为使用次数也决定先后位置. 不过, 具体实现而言, 为了减少计算/省事, 直接放链表头也可以, 在请求时间分布比较均匀的情况下.
2. 如果存在: 将该元素插入合适位置.
3. 修改受影响的元素前后节点的指针指向.

查询时遍历: 构建链表, 当插入新元素时, 遍历链表, 判断链表中是否已经存在该元素
1. 如果不存在: 首先判断内存是否充足, 是则直接追加数据到链表, 否则遍历数组, 找出lru块替换之.
  - lru块: 最近最少使用的块, 即要被替代的块.
2. 如果存在: 直接取出.

为了避免内存拷贝造成的浪费, 插入时排序算法 一般使用指针指向真正的内存块, 更新时只更新指针指向, 从而避免内存拷贝. 而 查询时遍历算法 无需考虑这种情况.

综上, 当注重性能时, 考虑 插入时排序算法, 不需要整体遍历去查找lru块. 注重空间时, 考虑 查询时遍历算法, 不需要存储前后节点, 指向内存块的指针等.

有时, 我们不需要完全遵循 LRU 规则, 所以可以使用一些去巧的方法 牺牲一丢丢精准性获得巨大的性能提升. 如上述的 合适位置, 以及 redis 中的 lru 算法.

----

伪代码如下

定义如下指针, iterator 用于迭代链表, target 用于记录查询到的LRU块, preTarget 用于记录target的前一个节点.

```Go
for _, iterator := range list{
  if LRU {
    preTarget = target
    target = preTarget
  }
}
```

## redis
[redis源码](https://github.com/antirez/redis)

### 替换策略
redis LRU 算法并不是完全遵守LRU规则的(即不一定是最近最少使用的块被替换)

redis 随机取出N个值, 然后从替换掉这N个值中符合LRU的块. N 由 maxmemory-samples 配置项指定.
