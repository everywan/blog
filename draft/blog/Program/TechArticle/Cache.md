# 缓存穿透&缓存雪崩
> [参考](https://segmentfault.com/a/1190000005886009)

<!-- TOC -->

- [缓存穿透&缓存雪崩](#缓存穿透缓存雪崩)
    - [缓存穿透](#缓存穿透)
    - [缓存雪崩](#缓存雪崩)
    - [缓存并发](#缓存并发)

<!-- /TOC -->

## 缓存穿透
1. 查询一个不存在的数据时, 缓存和存储层都不会命中, 由于存储层查不到数据则不写入缓存, 所以每次查询都会到存储层查询从而缓存失去了其存在的意义. 
2. 如何避免
    - 对查询为空的情况也进行缓存, 只不过设置一个较短的缓存时间. 
    - 把所有可能存在的key放到一个大的bitmap中, 查询时通过该bitmap过滤. 
    　　
## 缓存雪崩
1. 发生缓存穿透时或者缓存失效后, Storage层的调用量暴增从而使Storage也挂掉. 
2. 如何避免
    - 通过加锁或者队列控制数据库读写缓存的线程数量. 

## 缓存并发
1. 当网站并发比较高时, 可能存在多个线程/进程同时查询数据库, 同时设置缓存的情况. 这可能会造成Storage层压力过大, 或者缓存频繁更新的问题. 
2. 如何避免
    - 对缓存查询进行加锁：当key不存在时, 对缓存加锁, 然后查询数据库, 其他进程等待解锁后查询缓存或者数据库. 