# 浮点数精确度缺失

<!-- TOC -->

- [浮点数精确度缺失](#浮点数精确度缺失)
    - [问题](#问题)
    - [原因](#原因)
- [ETC](#etc)
    - [十进制(整数/小数)转化为二进制](#十进制整数小数转化为二进制)
    - [计算机中单精度的存储格式](#计算机中单精度的存储格式)

<!-- /TOC -->

## 问题
单精度的2.2转换为双精度后, 精确到小数点后13位后变为了2.2000000476837, 而单精度的2.25转换为双精度后, 变为了2.2500000000000, 为何2.2在转换后的数值更改了而2.25却没有更改呢?

## 原因
> 可以通过查看float/double的二进制存储方式解决这个问题.  原因是部分小数在精度允许范围内可以精确表示, 而有些不可以, 所以造成了单精度转多精度时, 出现上述问题. 

**示例**: 
数字2.2用科学计数法表示应该为：
````
0.2*2 = 0.4     0
0.4*2 = 0.8     0
0.8*2 = 1.6     1
0.6*2 = 1.2     1
0.2*2 = 0.4     0
````
可以看到. 0.2转换的二进制是一个无限循环的排列. 对于单精度数据来说, 尾数只能表示24bit的精度.   
但是这样存储方式, 换算成十进制的值, 却不会是2.2的, 应为十进制在转换为二进制的时候可能会不准确, 如2.2, 而double类型的数据也存在同样的问题, 所以在浮点数表示中会产生些许的误差, 在单精度转换为双精度的时候, 也会存在误差的问题, 对于能够用二进制表示的十进制数据, 如2.25, 这个误差就会不存在, 所以会出现上面比较奇怪的输出结果. 

# ETC

## 十进制(整数/小数)转化为二进制
1. 整数除以2, 商继续除以2, 得到0为止, 将余数逆序排列, 得到十进制整数转换后的二进制序列
2. 小数乘以2, 取整, 小数部分继续乘以2, 取整, 得到小数部分0为止, 将整数顺序排列. 
**示例**
22.8125(10) == 10110.1101(2)
````
# 小数
0.8125x2=1.625 取整1,小数部分是0.625
0.625x2=1.25 取整1,小数部分是0.25
0.25x2=0.5 取整0,小数部分是0.5
0.5x2=1.0 取整1,小数部分是0
# 整数
22 / 2  11 余 0
11 / 2  5  余 1
5 / 2   2  余 1
2 / 2   1  余 0
1 / 2   0  余 1
````

## 计算机中单精度的存储格式
~~有时间了再了解吧~~