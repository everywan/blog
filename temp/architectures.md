# 计算机体系结构

## 内存
高速缓存块/行/组
- 缓存行 = 有效位 + 标记 + 一个告诉缓存块

内存地址与高速缓存地址的对应: `标记位|组偏移地址位|块偏移地址位`
- 注意: 内存地址是输入, 高速缓存根据一定的规则映射内存地址到高速缓存地址.
- 强调这个是因为我开始总以为缓存地址是缓存自己生成管理的, 其实并不是. 其就是内存地址, 缓存地址只是 规则映射+内存地址
- 块偏移地址: 一个缓存行只有一个内存块, 但一个内存块中有多个地址, 块迁移地址 决定所取的数据.

标记位用于比对内存块数据是否是想要取的地址

为什么使用中间位作组索引, 而不是高位?
- 以 直接相连高速缓存 举例, 当使用高位索引时, 连续的内存块被分到同一个缓存组, 而使用中间位索引时, 连续的内存块分配到不同的缓存组中
- 虽然不一定适合所有情况, 但是大多数情况下, 使用中间位索引可以提高 高速缓存 的使用率.

标记位用于比对内存块数据是否是想要取的地址

块是读写的最小单位, 对于CPU调度而言. 高速缓存行一次写入/读取一个块

高速cache写: 假设要写的数据为w
1. 存在问题
  - 写命中(高速cache中已经缓存了字w)时, 如何在低层次缓存中更新该字节的值
  - 写不命中时, 如何更新值.
2. 解决
  - 写命中时
    - 直写: 直接更新到低一层cache中. 直写会占用更多的总线带宽
    - 写回: 当高速cache中的数据被替换时, 将该数据写到低一层cache中. 写回需要添加标志位标记该是否修改过(即是否需要重写, 只有修改数据才需要写)
  - 写不命中
    - 写分配: 加载相应的低一层缓存到高速缓存中, 然后更新高速cache, 问题回到第一个问题
    - 非写分配: 直接写到低一层缓存中
  - 直写高速cache一般是非写分配的, 写回高速cache一般是写分配的

练习题

1. 假设 高速缓存为直接相连高速缓存, 有2个组, 高速缓存大小为 32 字节, 每个内存块大小为 16 字节. 对于如下程序, 是否存在问题
  ```C
  float dotprod(float x[8], float y[8]){
    float sum = 0.0;
    int i;
    for (i=0;i<8;i++){
      sum += x[i] + y[i];
    }
    return sum
  }
  ```

解答
1. 注意, 组索引是内存地址的偏移值, 所以在假设情况情况下, 缓存组E=1, 块偏移b=4. 内存地址为 x: 0x00-0xff, y: 0x0100-0x01ff 都会被映射到组0. 详细流程如下(指令顺序串行执行)
  - 进入for循环
  - 读取 x[0], 地址 0x0000, 二进制后5位: 00000, 缓存组0. 有效位为 0, 将数据加载到高速缓存组0
  - 读取 y[0], 地址 0x0100, 二进制后5位: 00000, 缓存组0. 标记不匹配, 将数据加载到缓存组0, 覆盖原数据
  - 读取 x[1], 地址 0x0001, 二进制后5位: 00001, 缓存组0, 标记不匹配, 将数据加载到缓存组0, 覆盖原数据
  - 后续依次类推
  - 所以, 上述情况可导致高速cache反复的写入和加载, 影响效率. 此现象称为 缓存抖动.
  - 解决方法: 传入的 x[8] 变为 x[12] 即可(将 y[0]-y[3] 映射到了组1)
